<html>
	<head>
    <title>Wheel of Levels</title>
	</head>
	<body>
		<canvas height="100" width="100" id="pattern" style="display:none;"></canvas>
	</body>
	<script type="text/javascript">
	
let baseSize = Math.floor(Math.min(window.innerWidth, window.innerHeight));
let margin = 50;
let r = (baseSize / 2) - margin;
let center = (baseSize / 2);

let canvas = document.createElement("canvas");
canvas.height = baseSize;
canvas.width = baseSize;
canvas.style.position = "fixed";
canvas.style.left = "0";
canvas.style.top = "0";
document.body.appendChild(canvas);
let ctx = canvas.getContext("2d");
document.body.style.backgroundColor = "magenta";

let items = [];

// need to avoid color offset to allow for chroma-key
let colorOffset = Math.random()*360;
colorOffset = 0;
let rotation = 0;
let rotationSpeed = 0;


let confetti = [];
let music = null;
let cheer = null;

let totalWeight = 0;

function init() {
	let ytid = RandomFrom([
		"gDn4NRVkG4Y", // BK Furnace Fun
		"RMhhcz8wfEU", // SMRPG victory
		"OhLVrfMKiKg", // DK64 bonus
		"72qGczM5OTs", // runaway 5
		"WV_0d4KfpK0", // Pilotwings intro
		"3EjSwg-eNAo&t=11", // DKC3 bonus
		"ABr_f0pV_y0", // SM64 slide
		"yIFloLCk_Y0", // MK64 time trial
		"g5qo57gwn9s", // SSB64 bonus,
		"bcTk-xyIkug", // BKN&B bonus
	]);
	if (!ytid) ytid = "gDn4NRVkG4Y";
	music = PlayAudio(ytid);
	for (let i = 0; i < 100; i++) {
		confetti.push({
			x: Math.random() * window.innerWidth,
			y: Math.random() * window.innerHeight,
			timer: 100 * Math.random(),
			color: ["red","blue","lime"][Math.floor(Math.random()*3)]
		});
	}
	
	let cumulativeWeight = items.map(x => x.weight).reduce((a,b) => a+b, 0);
	let weightScale = 1;
	if (cumulativeWeight < 16) {
		weightScale = Math.pow(2, 4 - Math.floor(Math.log2(cumulativeWeight)));
		if (weightScale < 1) weightScale = 1;
	}
	
	for (let item of items) {
		item.text = item.name.substring(0,14);
		item.weight *= weightScale;
	}
	totalWeight = items.map(x => x.weight).reduce((a,b)=>a+b,0);

	createPatterns();
	setInterval(loop, 1000/60);
	setupTimers();
}

let starPattern = null;
function createPatterns() {
	let c = document.getElementById("pattern");
	let patternCtx = c.getContext("2d");
	patternCtx.translate(50,50);
	patternCtx.fillStyle = "rgba(0,0,0,0.2)";
	patternCtx.beginPath()
	patternCtx.moveTo(0,0)
	for (let i=0; i<6; i++) {
		let rad = (2 * Math.PI*2 / 5 * i) - Math.PI/2;
		patternCtx.lineTo(50 * Math.cos(rad),50 * Math.sin(rad));
	}
	patternCtx.fill();
	starPattern = ctx.createPattern(c, "repeat");
}

function draw() {
	ctx.clearRect(0,0,baseSize, baseSize);
	
	let cumulativeWeight = 0;
	for (let index = 0; index < items.length; index++) {
		let item = items[index];
		// 270 instead of 360 and +20 to aoid magentas (chroma-key)
		let hue = Math.floor(270 / items.length * index + colorOffset) % 360 + 20;
		let sat = "75%";
		let lum = "50%";
		if (winnerIndex > -1 && winnerIndex !== index) {
			sat = "25%";
			lum = "75%";
		}
		let color = "hsl(" + hue + ", " + sat + "," + lum + ")";
		item.t1 = cumulativeWeight / totalWeight * (2*Math.PI);
		item.t2 = (cumulativeWeight + item.weight) / totalWeight * (2*Math.PI);
		
		cumulativeWeight += item.weight;	
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.moveTo(center, center);
		ctx.arc(center, center, r, item.t1+rotation, item.t2+rotation);
		ctx.lineTo(center, center);
		ctx.fill();
		if (item.badges.some(x => x.toLowerCase().indexOf("subscriber") > -1)) {
			ctx.fillStyle = starPattern;
			ctx.fill();
		}
	}
	ctx.fillStyle = "black";
	for (let i=0; i<cumulativeWeight; i++) {
		let theta = Math.PI*2 / cumulativeWeight * i + rotation;
		let x = center + r * Math.cos(theta);
		let y = center + r * Math.sin(theta);
		ctx.beginPath();
		ctx.arc(x, y, 5, 0, 2*Math.PI);
		ctx.fill();
	}
	ctx.beginPath();
	ctx.moveTo(center, margin);
	ctx.lineTo(center+15, 5);
	ctx.lineTo(center, 0);
	ctx.lineTo(center-15, 5);
	ctx.fill();
	
	
	// outlines
	ctx.lineWidth = 2;
	ctx.strokeStyle = "black";	
	ctx.beginPath();
	ctx.arc(center, center, r, 0, 2*Math.PI);
	ctx.stroke();
	for (let item of items) {	
		ctx.beginPath();
		ctx.moveTo(center, center);
		ctx.lineTo(center + r * Math.cos(item.t1+rotation), center + r * Math.sin(item.t1+rotation));
		ctx.stroke();
	}
	
	
	// name labels
	ctx.fillStyle = "white";
	ctx.strokeStyle = "black";	
	ctx.lineWidth = 5;
	let textHeight = 30;
	ctx.font = textHeight + "px Arial";
	if (winnerIndex <= -1) {
		for (let nameIndex = 0; nameIndex < items.length; nameIndex++) {
			if (nameIndex >= nameRevealCount) break;
			if (nameIndex < nameHideCount) continue;
			let item = items[nameIndex];
			let textWidth = ctx.measureText(item.text).width;
			let centerX = center + 0.75 * r * Math.cos((item.t1+item.t2)/2+rotation);
			let centerY = center + 0.75 * r * Math.sin((item.t1+item.t2)/2+rotation);
			ctx.strokeText(item.text, centerX - textWidth/2, centerY + textHeight/4);
			ctx.fillText(item.text, centerX - textWidth/2, centerY + textHeight/4);
		}	
	}
	
	// winner name text
	ctx.font = "50px Arial";
	if (winnerIndex > -1) {
		let winner = items[winnerIndex];
		let text = winner.name;
		let textWidth = ctx.measureText(text).width;
		ctx.strokeText(text, center - textWidth/2, center);
		ctx.fillText(text, center - textWidth/2, center);
		
		text = "wins!"
		textWidth = ctx.measureText(text).width;
		ctx.strokeText(text, center - textWidth/2, center + 60);
		ctx.fillText(text, center - textWidth/2, center + 60);
		
		// confetti
		for (let c of confetti) {
			ctx.fillStyle = c.color;
			for (let a =0; a<4; a++)
				ctx.fillRect(c.x, c.y + a * window.innerHeight/4, 3, 3);
		}
	}
}

function determineWinner() {
	// PI/2 == bottom
	let targetAngle = 3*Math.PI/2;
	let winner = null;
	for (let x of items) {
		let p1 = (x.t1 + rotation) % (Math.PI*2);
		let p2 = (x.t2 + rotation) % (Math.PI*2);
		if (p2 <= p1) p2 = p1 + Math.PI*2;
		if (p1 < targetAngle && p2 >= targetAngle) winner = x;
	}
	winnerIndex = items.indexOf(winner);
	
	setTimeout(() => {SendCode(winner.code)}, 100);

	setTimeout(() => {
		if (music) music.close();
		if (cheer) cheer.close();
		window.close();
	}, 8000);
}

let nameRevealCount = 0;
let nameHideCount = 0;
let rotationAccel = 1;
let winnerIndex = -1;
function setupTimers() {
	let timer = 0;
	
	timer += 2000;
	
	// show and hide name tags
	for (let i=0; i<items.length; i++) {
		setTimeout(() => {nameRevealCount++}, timer);
		timer += 200;
	}
	timer += 3000;
	// for (let i=0; i<items.length; i++) {
	// 	setTimeout(() => {nameHideCount++}, timer);
	// 	timer += 200;
	// }
	// timer += 500;

	// start spinning
	setTimeout(() => {rotationSpeed = 0.01}, timer);
	timer += 5;
	// speed up
	setTimeout(() => {rotationAccel = 1.02}, timer);
	timer += 2000;
	
	// steady speed for a random duration
	setTimeout(() => {rotationAccel = 1.00}, timer);
	timer += 2000 + 1000*Math.random();
	
	// dampen speed
	setTimeout(() => {rotationAccel = 0.99}, timer);
	timer += 9000;
	setTimeout(() => {rotationAccel = 0.9}, timer);
	timer += 1000;
	
	// hard stop
	setTimeout(() => {cheer = PlayAudio("barWV7RWkq0");}, timer);
	setTimeout(() => {rotationSpeed = 0; rotationAccel = 1.00;}, timer);
	timer += 1000;
	
	// highlight winner cell
	setTimeout(determineWinner, timer);
	timer += 1000;
}

function SendCode(code) {
	console.log("Sending code " + code);
	(new BroadcastChannel('helper')).postMessage('!randomwin ' + code);
}


function loop() {	
	draw();
	rotationSpeed *= rotationAccel;
	rotation += rotationSpeed;
	
	for (let c of confetti) {
		c.y += c.timer/100 + 1;
		if (c.y > window.innerHeight/4) c.y -= window.innerHeight/4;
		c.x += (c.timer - 50)/50;
		c.timer +=1;
		if (c.timer > 100) c.timer -= 100;
	}

	let currentPie = Math.floor(rotation / (Math.PI*2 / totalWeight));
	let previousPie = Math.floor((rotation-rotationSpeed) / (Math.PI*2 / totalWeight));
	if (currentPie !== previousPie) {
		PlayTone(440);
	}
	
}


function SetItems(x) {
	items = x;
}

function PlayAudio(ytid) {
	let w = window.open("https://www.youtube.com/watch?v=" + ytid);
	return w;
}

let context = new (window.AudioContext || window.webkitAudioContext)();
let volume = 1;
function PlayTone(frequency) {
    let oscillator = context.createOscillator();
    let gainNode = context.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(context.destination);
    oscillator.type = 'sine';
	
    oscillator.frequency.value = frequency;
    gainNode.gain.setValueAtTime(0, context.currentTime);
    gainNode.gain.linearRampToValueAtTime(volume/2, context.currentTime + 0.01);
            
    oscillator.start(context.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + 0.5);
    oscillator.stop(context.currentTime + 0.5);
}


function RandomFrom(list) {
	let index = RandomNumber(list.length) - 1;
	return list[index];
}
function RandomNumber(min, max) {
	if (max === undefined) {
		max = min;
		min = 1;
	}
	return min + Math.floor(Math.random() * (1+max-min))
}


	</script>
</html>
